/**
 * [编译过程]
 * 预处理（预处理命令）     -预处理器
 * 编译（汇编）            -编译器
 * 连接（将.o文件连接）     -连接器
 * 
 * [预处理]
 * 宏定义：由标识符来代表一个字符文本
 * 文件包含
 * 条件编译
 * 
 * 
*/
/**
 * [不带参数宏定义]不加分号
 * #define 宏名 字符文本
 * 不带参数宏定义，简单替换任何字符，预处理器不检查被替换的字符文本，
 * 
 * 字符文本特别容易产生不同结果，不进行运算
 * #define M1 a+b
 * #define M2 (a+b)
 * 
 * l=M1*M1;//宏展开 L=a+b*a+b
 * l=M2*M2;//宏展开 L=(a+b)*(a+b)
 * 
 * **重复定义的宏名只能最后一个有效**
 * #undef 用该命令取消宏定义
 * 
 * 范围：从#define开头到#undef结束或文件最后
 * 允许嵌套宏定义
 * #define width 80
 * #define length (width+10)
 * 第一个嵌套到第二个宏里面
 * 
*/
/**
 * [带参数宏定义]宏名和括号之间不能加任何字符
 * #define 宏名（参数表） 字符文本   参数表用逗号分隔的形式参数
 * 
 * 引用形式：宏名（引用参数表）
 * 应用参数表语宏定义的形参要求一一对应。
 * 
 * 预处理过程进行两次替换,
 * #define max(a,b) (((a)>(b))?(a):(b))
 * L=max(x-y,x+y);
 * 
 * 字符文本参数必须是独立字符参数
 * #define areg(x) l=Bareg+5;
 * #define areg(x) l=B+areg+5;
 * 
 * 行连接符“\”
 * #define PRINTSTAR(n) {xxxxxx}
 * 
 * 宏定义与一般函数区别：
 * 宏定义在预处理时已经完成，不分配内存
 * 函数在执行阶段才调用，同时分配内存
 * 
 * 宏定义与内联函数区别：
 * 预处理期间完成，内联函数通过编译器实现
 * 内敛函数像宏一样展开，取消函数参数入栈，减少调用开销，但做参数类型检查，
 * 宏不需要任何检查，直接代替
 * 
*/
//行连接符“\”,用PRINTSTAR(n)代替后面一整个for循环，增加{}形成复合语句
// #define PRINTSTAR(n) {\
//     int i,j;\
//     for(i=1;i<=n;i++){\
//         for(j=1;j<=i;j++){\
//             printf("*");\
//         }\
//         printf("\n");\
//     }\
// }\

/**
 * [#号运算符]文本参数“字符串化”
 * #define PRINT_MSG1(X) printf(#x);//自动将x转成字符串输出
 * #define PRINT_MSG1(X) printf(x); //直接打印输出x失败！
 * 
 * [##双井号运算符]将两个字符文本连接成一个字符文本，如果是宏定义参数，参数替换后再连接
 * #define SET1(arg) A##arg=arg;
 * #define SET1(arg) Aarg=arg;
 * SET1(1);//调用后A1=1;
 * SET1(1);//调用后Aarg=1;
 * 
 * 
*/
/**
 * 常见预定义符号常量
 * _DATE_   编译时的日期
 * _TIME_   编译时的时间
 * _FILE_   文件名
 * _LINE_   代码行
 * _STDC_   检测编译器系统是否支持C语言标准
 * 
 * 
*/

#include <stdio.h>
int M1(int y)
{
    return ((y)*(y));
}
#define M2(y) ((y)*(y))

int main()
{
    int i,j;
    for(i=1,j=1;i<=5;i++) printf("%d ",M1(j++));//函数调用处理
    printf("\n");

    /*整个过程：先看宏定义，将(y)*(y)带入到M2中的y,也就是M2中的y=y*y
    再将该y带入到printf的输出项列表M2中，得M2((y*y)++);*/

    for (i=1,j=1;i<=5;i++) printf("%d ",M2(j++)); //宏引用处理
    
    printf("\n");
    return 0;
}


